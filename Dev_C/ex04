#include <stdio.h>
#include <stdlib.h>
#include <time.h> 

// 260102

void swap(int *a, int *b){
	// 이 함수가 하는 역할은 a, b의 값을 받고 두 값을 바꾸는 것. 
	
	int p = *a;
	*a = *b;
	*b = p;
	
	return ;
}

void line(){
	int x = 0;
	printf("\n");
	while (x < 51){
		printf("-");
		x++;
	}
	printf("\n\n");
	
	return ;
}

void division(int x, int y, int *r){
	r[0] = x / y;
	r[1] = x % y;
	
	return;
}


typedef struct Human{
	char name;
	int age;
}Human;

Human f(char name, int age){
	Human x;
	x.name = name;
	x.age = age;
	
	// 와 씽 개신기해 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ; 
	return x;
}



// --------------------------------------------------------------------------------------------------------------
// 완벽한 가위바위보 만들기 

void banner(){
	// 가위바위보 게임의 상단 배너 실행시키는 함수 
	printf("========================\n");
	printf(" 가위바위보 게임입니다.\n");
	printf("   바로 시작해볼까요?   \n");
	printf("========================\n");
	
	return;
}

// choose result 합하기. 
int result(){
	// 가위 바위 보자기를 선택 후 결과 출력하기
	int x;
	printf("원하시는걸 선택해주세요!\n");
	printf("1. 가위\n2. 바위\n3. 보자기\n>> ");
	scanf("%d", &x);
	printf("\n");
	
	// 가위바위보 게임의 선택의 결과 실행 함수.
	if(x == 1){
			printf("가위를 선택하셨군요!\n");
	}else if(x == 2){
		printf("바위를 선택하셨군요!\n");
	}else if(x == 3){
		printf("보자기를 선택하셨군요!\n"); 
	}else{
		printf("다시 선택해주세요!"); 
	}	
	
	return x;
}

int computer(){
	// 컴퓨터의 선택을 랜덤으로 하나 뽑기 함수. 
	srand(time(NULL));
	int cpt = rand() % 3 + 1;
	
	return cpt;
}

void fight(int user, int computer, int *winlate){
	
	// user와 computer의 선택 비교해서 결과알려주는 함수.
	// + 전적도 추가하기
	if(user == computer){
		printf("컴퓨터의 선택도 같았답니다!\n비겼습니다!");
		winlate[2] = winlate[2] + 1;
	}else{
		if(user == 1 && computer == 2){
			printf("컴퓨터의 선택은 바위!!\n당신이 졌답니다!~");
			winlate[1] = winlate[1] + 1;
		}else if(user == 1 && computer == 3){
			printf("컴퓨터의 선택은 보자기!!\n당신이 이겼답니다!~");
			winlate[0] = winlate[0] + 1;
		}else if(user == 2 && computer == 3){
			printf("컴퓨터의 선택은 보자기!!\n당신이 졌답니다!~");
			winlate[1] = winlate[1] + 1;
		}else if(user == 2 && computer == 1){
			printf("컴퓨터의 선택은 가위!!\n당신이 이겼답니다!~");
			winlate[0] = winlate[0] + 1;
		}else if(user == 3 && computer == 1){
			printf("컴퓨터의 선택은 가위!!\n당신이 졌답니다~");
			winlate[1] = winlate[1] + 1;
		}else{
			printf("컴퓨터의 선택은 바위!!\n당신이 이겼답니다~");
			winlate[0] = winlate[0] + 1;
		}
	}
	printf("\n\n");
	line();
	return;
}

void rspPlus(){
	// 실행부터 결과까지 출력함수.
	int select = 0;
	int select2 = 2;
	int count = 0;
	int winlate[3] = {0, 0, 0};
	
	printf("가위바위보를 실행하시겠습니까?\n");
	printf("1. O	2. X\n");
	scanf("%d", &select);
	if(select == 1){
		banner();
		int user = result(); 
		int cpt = computer();
		fight(user, cpt, winlate);
		count = count + 1;
		printf("현재 %d판 째입니다.\n", count); 
		printf("당신의 전적은 %d승 %d패 %d무입니다!\n", winlate[0], winlate[1], winlate[2]);
		line();
	}else if(select == 2){
		printf("넵");
	}else{
		printf("1과 2만 선택해주세요.");
	}
	select = 1;
	
	while(select <= select2){
		printf("다시 한번 도전하시겠습니까?\n");
		printf("1. O	2. X\n");
		printf(">> ");
		scanf("%d", &select);
		if(select == 1){
		// 가위바위보를 다시 실행할 것인가?	
			printf("다시 실행하겠습니다!\n");
			select2 = select2 + 1;
			count = count + 1;
			banner();
			int user = result(); 
			int cpt = computer();
			fight(user, cpt, winlate);
			printf("현재 %d판 째입니다.\n", count);
			printf("당신의 전적은 %d승 %d패 %d무입니다!", winlate[0], winlate[1], winlate[2]);
		}else{
			printf("그만하겠습니다!\n");
			select = select2 + 1;
		}
	}
	printf("당신의 전적은 %d승 %d패 %d무입니다!", winlate[0], winlate[1], winlate[2]);
	
}


// --------------------------------------------------------------------------------------------------------------
int main(){
	//260102
	
	
	// pointer / 주소값(*N)
	// pointer를 선언할 때 들어가는 주소값은 정수로만 저장되기 때문에 int를 사용한다.
	
	
	// ex)
	// int n = 10;(n의 주소가 #100이라고 가정) 
	// int *p; -> p = &n; 이런 방식으로 작성.
	// *p에는 주소값을 넣어야 하기 때문에 &n(n의 주소)을 대입시킨다.
	// 즉 p(의 주소가 #400이라고 가정하면)의 pointer는 #400 - #100이 됨 
	
	// 메모리공간에는 stack과 heap이 있다.
	// stack는 이름을 저장하는 것(p가 이 역할을 담당).
	// heap은 오로지 주소만 저장되어있는 공간(#400 - #100이이 역할을 담당)
	// 이 때 스택은 선입후출.
	// 함수로 예를 들면 main() - f3() - f2() - f1() 순서로 처리가 되지만, 
	// f1() - f2() - f3() - main() 순서로 완료될때까지 먼저 들어온 것이 기다리게된다. 이게 선입 후출의 개념이다. 
	
	/*
	int n = 10;
	int *p;
	p = &n;
		
	printf("p에 저장되어 있는 값: %d\n", *p);	// 만약 n을 사용할 수 없다고 가정하고 n의 값을 p로 불러와야 할 때 
	printf("n의 주소는?: %d\n", &n);
	printf("p의 주소는?: %d\n", &p);
	printf("그냥 p를 써보면?: %d\n", p);
	// 즉 그냥 p를 출력하면 n의 주소가 저장된게 맞고, p 본인의 주소는 또 다른곳에 있다. 
	printf("시험해보기: %d\n", p + 1); 
	printf("시험해보기: %d\n", p + 2);
	
	line();
		
	int x = 5;
	int y = -2;
	int *px = &x;
	int *py = &y;
	
	printf("p(x)는 %d입니다.\n", px);
	printf("p(y)는 %d입니다.\n", py);
	printf("p(x-y)의 값은: %d 입니다.\n", *px -*py); 
	printf("x-y => 5 - -2 = 7\n\n");
	
	line();
	
	*/
	

	//swap이라는 함수를 생성
	// x에는 10, y에는 20을 대입.
	// p(x, y) -> x: 10, y: 20이 출력되게 하기 
	// swap(x, y)를 하면 x에 있는 값은 y에,  y에 있는 값은 x에 넣기.  
	printf("swap이라는 함수를 생성 후 두 가지 x, y를 받고, x와 y의 값을 교체\n");
	int x = 10;
	int y = 20;
	int *px = &x;
	int *py = &y;
	printf("(x, y) -> x: %d, y: %d\n", *px, *py);
	printf("swap(x, y)을 하게 되면?\n");
	swap(&x, &y);
	printf("(x, y) -> x: %d, y: %d", *px, *py);
	
	printf("\n\n");
	
	
	line(); 
	
	// 배열의 이름은 곧 주소다.
	// 배열과 포인터의 개념을 동일시 보고, 사용하는 방법 
	
	printf("예시 한 번 적어볼까요?");
	int A[3] = {1, 2, 3};
	int *p;
	p = A;
	printf("%d\n", p);
	printf("%d\n", A[0]);
	printf("%d\n", *(p+0));
	
	// 하지만 배열은 생성하는 순간 다른 주소를 받을 수 없고, 포인터는 가능하다. 
	
	line();
	
	// 메인함수에서 나눗셈 함수에 2개의 숫자를 던져주고, 나눗셈 함수는 받은 숫자를 나누고 몫과 나머지를 나누어 주는 것.
	// 보낼 숫자 2개. 
	printf("메인함수에서 나눗셈 함수에 2개의 숫자를 던져주고, \n나눗셈 함수는 받은 숫자를 나누고 몫과 나머지를 나누어 주기.\n");
	int a = 50;
	int b = 4;
	// 받을 배열 2칸. 
	int c[2];	// 함수가 포인트로 주소값을 받게되지 않아도, 배열을 함수에 보내게 되면 배열의 주소값이 전달됨. 
	
	division(a, b, c);
	printf("-> 받은 몫은 %d, 나머지는 %d 입니다.\n", c[0], c[1]);
	
	
	line();
		
	
	
	// 구조체의 정체는? 자료형이다. 만든사람은? 우리~ 
	
	
	// 정석 
	/*
	struct Human h1;
	h1.name='A';
	h1.age = 23;
	*/
	
	
	// 간단하게 
	/*
	struct Human h1 = {
		'A', 35
	}; 
	printf("%c, %d", h1.name, h1.age);
	*/
	
	printf("f를 통해 값 두가지를 보내고, 구조체를 통해 출력해보기.\n");
	Human h = f('Z', 26);
	printf("%c, %d\n", h.name, h.age);	//Z, 26
	
	line();
	
	// 가위바위보 게임 만들기. 
	// 랜덤을 사용하고, 컴퓨터와 1대1을 하게되며, 나는 선택, 컴퓨터는 랜덤수.
	// 이기냐 비기냐, 지냐를 만들기.
	// +로 전적까지 출력할수 있다면 오케이! 
	// 1단계 - 1번만 하기.
	// 2단계 - 원하는 횟수만큼 하기.
	// 3단계 - 원하는 횟수만큼 하고 전적까지 출력하는 것 
	// 4단계 - 함수를 사용해보기.
	// 5단계 - 구조체를 써보기.
	
	
	rspPlus(); 
	
	
	return 0;
}


